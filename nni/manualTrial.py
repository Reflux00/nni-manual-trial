# Copyright (c) Microsoft Corporation.
# Licensed under the MIT license.

from __future__ import annotations

from typing import Any, cast, Dict

from .runtime.env_vars import _trial_env_var_names, _load_env_vars
from .runtime.trial_command_channel import get_default_trial_command_channel
from .runtime.trial_command_channel.standalone import StandaloneTrialCommandChannel
from .runtime.trial_command_channel.v3 import TrialCommandChannelV3, TrialCommandChannel
from .typehint import Parameters, TrialMetric, ParameterRecord
from .experiment.remoteExperiment import Experiment
from .runtime.command_channel.http import HttpChannel

import os
import time

__all__ = [
    'manual_get_next_parameter',
    # 'get_next_parameters',
    'manual_get_current_parameter',
    'manual_report_intermediate_result',
    'manual_report_final_result',
    # 'get_experiment_id',
    # 'get_trial_id',
    # 'get_sequence_id',
    'manual_set_experiment',
    'manual_update_experiment',
]

trial_env_vars = _load_env_vars(_trial_env_var_names)

_set_trial_start = {'type':'set_trial_start'}
_set_trial_stop = {'type':'set_trial_stop', 'exitCode': 0}

_params: ParameterRecord | None = None
_experiment_id = trial_env_vars.NNI_EXP_ID or 'STANDALONE'
_trial_id = trial_env_vars.NNI_TRIAL_JOB_ID or 'STANDALONE'
_sequence_id = int(trial_env_vars.NNI_TRIAL_SEQ_ID) if trial_env_vars.NNI_TRIAL_SEQ_ID is not None else 0

_exp: Experiment|str = None
trialIdQueue: Dict[str: str] = {}
trialChannelQueue: Dict[str: TrialCommandChannel] = {}
trialParameterQueue: Dict[str: ParameterRecord] = {}
trialInfoChannelQueue: Dict[str: HttpChannel] = {}
trialStartTimeQueue: Dict[str: float] = {}


def manual_update_experiment(port, ip='localhost'):
    global _exp, IP
    _exp = Experiment(None).connect(port, ip)            

def manual_set_experiment(exp: Experiment):
    global _exp
    assert isinstance(exp, Experiment) or exp == 'DEBUG', "exp should be an instance of Experiment or 'DEBUG' "
    _exp = exp

def _update_trial_env_vars():
    global trial_env_vars
    global _experiment_id
    global _trial_id
    global _sequence_id

    trial_env_vars = _load_env_vars(_trial_env_var_names)
    _experiment_id = trial_env_vars.NNI_EXP_ID or 'STANDALONE'
    _trial_id = trial_env_vars.NNI_TRIAL_JOB_ID or 'STANDALONE'
    _sequence_id = int(trial_env_vars.NNI_TRIAL_SEQ_ID) if trial_env_vars.NNI_TRIAL_SEQ_ID is not None else 0

def update_trial_env(env):
    '''
    Update the trial environment variables with the given sequence_id from the manager.
    '''
    os.environ.update(env)
    _update_trial_env_vars()


def get_trial_env(sequence_id):
    '''
    Get the trial environment variables with the given sequence_id from the manager.
    '''
    global trialInfoChannelQueue

    port = _exp.port
    ip = _exp._nni_manager_ip

    trial_info_url = f'http://{ip}:{port}/trial-info/manual-env/{sequence_id}'
    channel = HttpChannel(trial_info_url)
    trialInfoChannelQueue[sequence_id] = channel

    data = channel.receive()
    assert data['type'] == 'trial_info', f'get trial info failed: {data}, url: {trial_info_url}'
    try:
        env = data['env']
    except Exception as e:
        raise RuntimeError(f'Failed to get trial environment variables from {trial_info_url}') from e
    
    channel.send(_set_trial_start)
    data = channel.receive()
    while data['trial_status'] != 'RUNNING':
        channel.send(_set_trial_start)
        time.sleep(0.05)
        data = channel.receive()

    trialStartTimeQueue[sequence_id] = time.time()

    return env

def manual_get_next_parameter(sequence_id:int) -> Parameters:
    """
    Get the hyperparameters generated by tuner.

    Each trial should and should only invoke this function once.
    Otherwise the behavior is undefined.

    Examples
    --------
    Assuming the :doc:`search space </hpo/search_space>` is:

    .. code-block::

        {
            'activation': {'_type': 'choice', '_value': ['relu', 'tanh', 'sigmoid']},
            'learning_rate': {'_type': 'loguniform', '_value': [0.0001, 0.1]}
        }

    Then this function might return:

    .. code-block::

        {
            'activation': 'relu',
            'learning_rate': 0.02
        }

    Returns
    -------
    :class:`~nni.typehint.Parameters`
        A hyperparameter set sampled from search space.
    """
    assert _exp is not None, 'Should call set_experiment or update_experiment first'

    if _exp != 'DEBUG':
        global trialParameterQueue, trialIdQueue, trialChannelQueue
        env = get_trial_env(sequence_id)
        update_trial_env(env)

        ip = _exp._nni_manager_ip
        # trial_channel_url =  trial_env_vars.NNI_TRIAL_COMMAND_CHANNEL
        # trial_channel_url = trial_channel_url.replace('localhost', ip)
        trial_channel_url = env['NNI_TRIAL_COMMAND_CHANNEL'].replace('localhost', ip)
        trial_id = env['NNI_TRIAL_JOB_ID']
        
        trial_command_channel =  TrialCommandChannelV3(trial_channel_url)
    else:
        trial_id = 'STANDALONE'
        trial_command_channel = StandaloneTrialCommandChannel()

    params = trial_command_channel.receive_parameter()

    trialParameterQueue[sequence_id] = params
    trialIdQueue[sequence_id] = trial_id
    trialChannelQueue[sequence_id] = trial_command_channel

    if params is None:
        return None  # type: ignore
    return params['parameters']


def manual_get_current_parameter(sequence_id, tag: str | None = None) -> Any:
    assert _exp is not None, 'Should call set_experiment or update_experiment first'

    params = trialParameterQueue.get(sequence_id, None)
    if params is None:
        return None
    if tag is None:
        return params['parameters']
    return params['parameters'][tag]

# def get_experiment_id() -> str:
#     """
#     Return experiment ID.
#     """
#     assert _exp is not None, 'Should call set_experiment or update_experiment first'
#     return _exp.id

# def get_trial_id(sequence_id: int) -> str:
#     """
#     Return unique ID of the trial that is current running.

#     This is shown as "ID" in the web portal's trial table.
#     """
#     assert _exp is not None, 'Should call set_experiment or update_experiment first'

#     return trialIdQueue[sequence_id]

# def get_sequence_id() -> int:
#     """
#     Return sequence nubmer of the trial that is currently running.

#     This is shown as "Trial No." in the web portal's trial table.
#     """
#     return _sequence_id

_intermediate_seq = 0
_trial_intermediate_seq_queue: dict[str, int] = {}


def overwrite_intermediate_seq(sequence_id: int, value: int) -> None:
    assert isinstance(value, int)
    global _trial_intermediate_seq_queue
    _trial_intermediate_seq_queue[sequence_id] = value


def manual_report_intermediate_result(sequence_id: int, metric: TrialMetric | dict[str, Any]) -> None:
    """
    Reports intermediate result to NNI.

    ``metric`` should either be a float, or a dict that ``metric['default']`` is a float.

    If ``metric`` is a dict, ``metric['default']`` will be used by tuner,
    and other items can be visualized with web portal.

    Typically ``metric`` is per-epoch accuracy or loss.

    Parameters
    ----------
    metric : :class:`~nni.typehint.TrialMetric`
        The intermeidate result.
    """
    global _trial_intermediate_seq_queue
    params = trialParameterQueue.get(sequence_id, None)

    assert params is not None, \
        f'nni.get_next_parameter() needs to be called before report_final_result of sequence id: {sequence_id}'

    trial_command_channel = trialChannelQueue.get(sequence_id) if _exp != 'DEBUG' else StandaloneTrialCommandChannel()
    intermediate_seq = _trial_intermediate_seq_queue.get(sequence_id, 0)
    
    trial_command_channel.send_metric(
        parameter_id=params['parameter_id'] if params else None,
        trial_job_id=trialIdQueue[sequence_id],
        type='PERIODICAL',
        sequence=intermediate_seq,
        value=cast(TrialMetric, metric)
    )
    _trial_intermediate_seq_queue[sequence_id] = intermediate_seq + 1

def manual_report_final_result(sequence_id: int, metric: TrialMetric | dict[str, Any]) -> None:
    """
    Reports final result to NNI.

    ``metric`` should either be a float, or a dict that ``metric['default']`` is a float.

    If ``metric`` is a dict, ``metric['default']`` will be used by tuner,
    and other items can be visualized with web portal.

    Typically ``metric`` is the final accuracy or loss.

    Parameters
    ----------
    metric : :class:`~nni.typehint.TrialMetric`
        The final result.
    """

    global trialParameterQueue, trialChannelQueue, trialIdQueue, trialInfoChannelQueue
    params = trialParameterQueue.get(sequence_id, None)
    info_channel = trialInfoChannelQueue.get(sequence_id, None)

    assert params and info_channel is not None, \
        f'nni.get_next_parameter() needs to be called before report_final_result of sequence id: {sequence_id}'
    
    trial_command_channel = trialChannelQueue.get(sequence_id) if _exp != 'DEBUG' else StandaloneTrialCommandChannel()
    runtime = time.time() - trialStartTimeQueue[sequence_id]
    time.sleep(0.5 - runtime if 0.5 - runtime > 0 else 0)

    trial_command_channel.send_metric(
        parameter_id=params['parameter_id'] if params else None,
        trial_job_id=trialIdQueue[sequence_id],
        type='FINAL',
        sequence=0,
        value=cast(TrialMetric, metric)
    )
    # fixme send one will report fail
    # trial_command_channel.send_metric(
    #     parameter_id=params['parameter_id'] if params else None,
    #     trial_job_id=trialIdQueue[sequence_id],
    #     type='FINAL',
    #     sequence=0,
    #     value=cast(TrialMetric, metric)
    # )
    info_channel.send(_set_trial_stop)

    # time.sleep(0.1)
    # # Fixme: if report too fast, the trial may not be stopped and try to send again
    data = info_channel.receive()
    while data['trial_status'] != 'DONE':
        info_channel.send(_set_trial_stop)
        time.sleep(0.1)
        data = info_channel.receive()

    trialParameterQueue.pop(sequence_id)
    trialIdQueue.pop(sequence_id)
    trialChannelQueue.pop(sequence_id)
    trialInfoChannelQueue.pop(sequence_id)
    trialStartTimeQueue.pop(sequence_id)